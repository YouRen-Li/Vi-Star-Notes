# 一、什么是 TS

> TypeScript www.typescriptlang.org 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 -- 官方文档

> 用一张图来描述一下 TS 和 JS 的关系，

![image.png](imgs/a8abe99b5abf4a5a8c2bdb3311644592_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

ts = js + 类型

JS 有的， TS 都有， JS 没有的， TS 也有，毕竟 TS 是 JS 的超集嘛。

TS 的缺点：

- 不能被浏览器理解，需要被编译成 JS
- 有学习成本，写习惯了 JS 的我们要上手需要花时间去理解，而且 TS 中有一些概念还是有点难，比如泛型。

## ts 的好处：

 强类型，支持静态和动态类型

 可以在编译期间发现并纠正错误

 不允许改变变量的数据类型



说人话就是 TS 拓展了 JS 的一些功能，解决了 JS 的一些缺点，可以总结在下面的表格里

## ts 和 js 的区别

| TypeScript                                      | JavaScript                       |
| ----------------------------------------------- | -------------------------------- |
| JavaScript 的超集，用于解决大型项目的代码复杂性 | 一种脚本语言，用于创建动态网页。 |
| 强类型，支持静态和动态类型                      | 动态弱类型语言                   |
| 可以在编译期间发现并纠正错误                    | 只能在运行时发现错误             |
| 不允许改变变量的数据类型                        | 变量可以被赋予不同类型的值       |

来个小栗子

js 代码

![image-20240224121333590](imgs/image-20240224121333590.png)

ts 代码

![image-20240224121351575](imgs/image-20240224121351575.png)

## ts 文档

官方文档 -https://www.typescriptlang.org/

官方文档中文翻译文档

https://gitee.com/wolfx/TypeScript-Handbook-zh

# 二、安装手动编译环境

为什么要编译 ts？

因为浏览器不认识 ts，只认识 js，所以需要一个工具把 ts 转化为 js，然后执行。

### 安装 typescript

```shell
npm install -g  typescript // 全局安装 ts
```

安装以后，我们就可以在终端使用 tsc 命令

不记得自己是否已经安装过 typescript 的，可以使用以下命令来验证：

```shell
tsc -v
```

如果出现版本，则说明已经安装成功

```shell
Version 5.3.3
```

然后，我们可以新建一个空文件夹，用来学习 ts，例如我在文件夹下新建了个 `helloworld.ts`

在我们`helloworld.ts`文件中,随便写点什么

```typescript
const s: string = "彼时彼刻，恰如此时此刻";
console.log(s);
```

控制台执行 `tsc helloworld.ts` 命令，目录下生成了一个同名的 helloworld.js 文件，代码如下

```js
var s = "彼时彼刻，恰如此时此刻";
console.log(s);
```

通过 tsc 命令，发现我们的 typescript 代码被转换成了熟悉的 js 代码

我们接着执行

```shell
node helloworld.js
```

即可看到输出结果

###

那么通过我们上面的一通操作，我们知道了运行 tsc 命令就可以编译生成一个 js 文件，但是如果每次改动我们都要手动去执行编译，然后再通过 node 命令才能查看运行结果岂不是太麻烦了。

# 三、使用 vite 自动编译

vite 是一种新型前端构建工具，能够显著提升前端开发体验，[官网](https://cn.vitejs.dev/guide/)

使用 vite 创建 ts 项目的命令(电脑需要提前安装好 node 环境)

```
npm create vite@latest xxxName -- --template vanilla-ts
```

上面命令，不需要记忆！

xxxName 是自己项目的名字，根据自己需求起名字即可

命令的含义是 使用最新的 vite 创建原生的 ts 项目

如果出现这个界面![image-20240224172957169](imgs/image-20240224172957169.png)

按回车就可以

接下来，根据提示操作就可以

```
  cd learn-ts  //进入目录
  npm install  //安装依赖
  npm run dev  //运行项目
```

运行以后可以根据提示打开测试网址

项目结构是这样

![image-20240224173652191](imgs/image-20240224173652191.png)

tsconfig.json 是编译 ts 的配置文件，知道就行

index.html 是我们的页面，index.html 引入了 main.ts,

我们在这里面写代码就行，main.ts 里面的代码可以删了，我们自己写一点 ts

```
let username = "zhangsan";
username = "lisi";
console.log(username);
```

打开测试网址就可以看到浏览器的执行结果，这样我们就不需要手动编译 ts 了。vite 会帮我们自己动编译 ts

![image-20240224174247449](imgs/image-20240224174247449.png)

接下来我们就可以正式进入到 typescript 的学习之旅了

# 四、类型注解（类型声明）

 所谓类型注解，也叫类型声明，意思就是给一个变量约束或者指定他们的类型。

 指定类型之后，变量不能赋值为其他类型，并且能获取到相关的类型代码提示。

TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。

```
let foo:string;
```

 上面示例中，变量`foo`的后面使用冒号，声明了它的类型为`string`。

这样声明以后，我们在使用 foo 变量的时候，还能获得相关的类型的代码提示

![image-20240224220613032](imgs/image-20240224220613032.png)

 如果我们 js 用的比较多，会发现有些时候 js 中调用方法不会得到类型提示。（弱类型，js 中有时候编辑器识别不了变量的类型）

### 类型声明语法

 类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。

 函数参数和返回值，也是这样来声明类型。

```
function toString(num:number):string {
  return String(num);
}
```

上面示例中，函数`toString()`的参数`num`的类型是`number`。参数列表的圆括号后面，声明了返回值的类型是`string`

注意，变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。

```
// 报错
let foo:string = 123;
```

上面示例中，变量`foo`的类型是字符串，但是赋值为数值`123`，TypeScript 就报错了。

另外，TypeScript 规定，变量只有赋值后才能使用，否则就会报错。

```
let x:number;
console.log(x) // 报错
```

上面示例中，变量`x`没有赋值就被读取，导致报错。而 JavaScript 允许这种行为，不会报错，没有赋值的变量会返回`undefined`。

# 五、类型总体介绍

TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。

### 1. js 已有类型

简单类型

- boolean，string，number，symbol，null，undefined，bigint

复杂类型

- object（对象，数组，函数）

TypeScript 继承了 JavaScript 的类型设计，以上 8 种类型可以看作 TypeScript 的基本类型。

注意，上面所有类型的名称都是小写字母，首字母大写的`Number`、`String`、`Boolean`等在 JavaScript 语言中都是内置对象，而不是类型名称。

另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。

这 8 种基本类型是 TypeScript 类型系统的基础，ts 中的复杂类型由它们组合而成。

### 2.TS 新增类型

接口，联合类型，自定义类型，元组，字面量类型，枚举类型，void，any等

# 六、js 已有类型的类型声明

### boolean 类型

`boolean`类型只包含`true`和`false`两个布尔值。

```
const x:boolean = true;
const y:boolean = false;
```

上面示例中，变量`x`和`y`就属于 boolean 类型。

### string 类型

`string`类型包含所有字符串。

```
const x:string = 'hello';
const y:string = `${x} world`;
```

上面示例中，普通字符串和模板字符串都属于 string 类型。

### number 类型

`number`类型包含所有整数和浮点数。

```
const x:number = 123;
const y:number = 3.14;
const z:number = 0xffff;
```

上面示例中，整数、浮点数和非十进制数都属于 number 类型。

### bigint 类型

bigint 类型包含所有的大整数。

```
const x:bigint = 123n;
const y:bigint = 0xffffn;
```

上面示例中，变量`x`和`y`就属于 bigint 类型。

bigint 与 number 类型不兼容。

```
const x:bigint = 123; // 报错
const y:bigint = 3.14; // 报错
```

上面示例中，`bigint`类型赋值为整数和小数，都会报错。

注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数`target`不低于`es2020`）。

### symbol 类型

symbol 类型包含所有的 Symbol 值。

```
const x:symbol = Symbol();
```

上面示例中，`Symbol()`函数的返回值就是 symbol 类型。



### undefined 类型，null 类型

undefined 和 null 是两种独立类型，它们各自都只有一个值。

undefined 类型只包含一个值`undefined`，表示未定义（即还未给出定义，以后可能会有定义）。

```
let x:undefined = undefined;
```

上面示例中，变量`x`就属于 undefined 类型。两个`undefined`里面，第一个是类型，第二个是值。

null 类型也只包含一个值`null`，表示为空（即此处没有值）。

```
const x:null = null;
```

上面示例中，变量`x`就属于 null 类型。

### object 类型

根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。

```
const x:object = { foo: 123 };
const y:object = [1, 2, 3];
const z:object = (n:number) => n + 1;
```

上面示例中，对象、数组、函数都属于 object 类型。

一般直接类型注解为 object 没多大作用！

下面我们来看数组的类型声明

# 七、数组的类型声明常见写法

## 写法一：（推荐）

```
let arr:number[] = [1,2,3,4]
```

这样写的好处是，1 限制的了变量类型是数组，2 限制了数组中元素的类型为数字

## 写法二：（泛型写法）

```
let arr:Array<number> = [1,2,3,4]
```

这样写同上面一样，1 限制的了变量类型是数组，2 限制了数组中元素的类型为数字

# 八、联合类型

联合类型（union types）指的是将多个类型组成的一个新类型，使用符号`|`表示。

## 联合类型语法

联合类型`A|B`表示，任何一个类型只要属于`A`或`B`，就属于联合类型`A|B`。

```
let x:string|number;

x = 123; // 正确
x = 'abc'; // 正确
```

上面示例中，变量`x`就是联合类型`string|number`，表示它的值既可以是字符串，也可以是数值。

联合类型可以与值类型相结合，表示一个变量的值有若干种可能。

```
let setting:true|false;

let gender:'male'|'female';

let rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫';
```

上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，`true|false`其实就是布尔类型`boolean`。

前面提到，打开编译选项`strictNullChecks`后，其他类型的变量不能赋值为`undefined`或`null`。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。

```
let name:string|null;

name = 'John';
name = null;
```

上面示例中，变量`name`的值可以是字符串，也可以是`null`。

联合类型的第一个成员前面，也可以加上竖杠`|`，这样便于多行书写。

```
let x:
  | 'one'
  | 'two'
  | 'three'
  | 'four';
```

上面示例中，联合类型的第一个成员`one`前面，加上了竖杠。

上面限制了 x 只能是后面几个字符串中的一个。

## 联合类型控制数组元素的类型

```
let arr (number|string)[] = [1,'zhangsan']
```

上面表示数组中可以有数字，也可以有字符串

## 类型缩小

如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。

```
function printId(
  id:number|string
) {
    console.log(id.toUpperCase()); // 报错
}
```

上面示例中，参数变量`id`可能是数值，也可能是字符串，这时直接对这个变量调用`toUpperCase()`方法会报错，因为这个方法只存在于字符串，不存在于数值。

解决方法就是对参数`id`做一下类型缩小，确定它的类型以后再进行处理。

```
function printId(
  id:number|string
) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

上面示例中，函数体内部会判断一下变量`id`的类型，如果是字符串，就对其执行`toUpperCase()`方法。

“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。

下面是“类型缩小”的另一个例子。

```
function getPort(
  scheme: 'http'|'https'
) {
  switch (scheme) {
    case 'http':
      return 80;
    case 'https':
      return 443;
  }
}
```

上面示例中，函数体内部对参数变量`scheme`进行类型缩小，根据不同的值类型，返回不同的结果。

# 九、类型别名

在八的案例中，如果我们需要给多个数组的元素都定义成 string|number 类型

```
let arr3 (string|number)[];
let arr4 (sting|number)[];
```

这样比较麻烦，能不能将 这个类型封装了，然后复用呢。可以用类型别名就可以

## 什么是类型别名

`type`命令用来给一个复杂的类型的起一个新的名字，叫类型别名。好处是可以简化有些类型的写法，可以复用。

```
let arr:(number|string)[] = [1,'aa']

//定义类型别名-相当于自定义的类型
type MyArray = (number|string)[];
//接下来再使用这种类型 ，就可以省事了
let arr2:MyArray = [2,'bb',1]
let arr3:MyArray = [2,'bb',1]
```

别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便

# 十、函数类型

### 声明式函数

 函数的类型声明，就是给出参数的类型和返回值的类型。

 参数这样限制，限制了参数必须传入，并且类型是 number

```Typescript
function add(x:number, y:number):number {
    return x + y
}
add(1,2)
```

![image-20240224225345521](imgs/image-20240224225345521.png)

好处：

避免传参错误

有代码提示

### 函数表达式写法

如果变量被赋值为一个函数，变量的类型有两种写法。

```Typescript
// 写法一(参数和返回值分开注解)
const hello = function (txt:string):number {
  console.log('hello ' + txt);
    return 1
}

// 写法二（整体注解hello变量的类型）
//(txt:string) => number 这个表示一个函数类型
const hello : (txt:string) => number
= function (txt) {
  console.log('hello ' + txt);
    return 1
};
//写法二也可以先定义类型别名再用
type hFn = (txt:string) => number
const hello : hFn = function (txt) {
  console.log('hello ' + txt);
    return 1
};
```

上面示例中，变量`hello`被赋值为一个函数，它的类型有两种写法。

写法一是通过等号右边的函数类型，推断出变量`hello`的类型；

写法二则是使用类似箭头函数的形式，为变量`hello`指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧。

写法二有两个地方需要注意。

首先，函数的参数要放在圆括号里面，不放会报错。

其次，类型里面的参数名（本例是`txt`）是必须的。有的语言的函数类型可以不写参数名（比如 C 语言），但是 TypeScript 不行。

函数类型里面的参数名与实际参数名，可以不一致。

```
let f:(x:number) => number;

f = function (y:number) {
  return y;
};
```

上面示例中，函数类型里面的参数名为`x`，实际的函数定义里面，参数名为`y`，两者并不相同。

如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。因此，往往用`type`命令为函数类型定义一个别名，便于指定给其他变量。

```
type MyFunc = (txt:string) => void;

const hello:MyFunc = function (txt) {
  console.log('hello ' + txt);
};
```

上面示例中，`type`命令为函数类型定义了一个别名`MyFunc`，后面使用就很方便，变量可以指定为这个类型。

函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。

```
let myFunc:
  (a:number, b:number) => number;

myFunc = (a:number) => a; // 正确

myFunc = (
  a:number, b:number, c:number
) => a + b + c; // 报错
```

上面示例中，变量`myFunc`的类型只能接受两个参数，如果被赋值为只有一个参数的函数，并不报错。但是，被赋值为有三个参数的函数，就会报错。

这是因为 JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数。比如，数组的`forEach()`方法的参数是一个函数，该函数默认有三个参数`(item, index, array) => void`，实际上往往只使用第一个参数`(item) => void`。因此，TypeScript 允许函数传入的参数不足。

如果一个变量要套用另一个函数类型，有一个小技巧，就是使用`typeof`运算符。

```
function add(
  x:number,
  y:number
) {
  return x + y;
}

const myAdd:typeof add = function (x, y) {
  return x + y;
}
```

上面示例中，函数`myAdd()`的类型与函数`add()`是一样的，那么就可以定义成`typeof add`。因为函数名`add`本身不是类型，而是一个值，所以要用`typeof`运算符返回它的类型。

这是一个很有用的技巧，任何需要类型的地方，都可以使用`typeof`运算符从一个值获取类型。

### 可选参数

参数后加个问号，代表这个参数是可选的

```Typescript
function add(x:number, y:number, z?:number):number {
    return x + y
}

add(1,2,3)
add(1,2)
```

注意可选参数要放在函数入参的最后面，不然会导致编译错误。

![image.png](imgs/6308853e2765455fb2e067c278d161bd_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### 默认参数

```ts
function add(x: number, y: number = 100): number {
  return x + y;
}

add(100); // 200
```

跟 JS 的写法一样，在入参里定义初始值。

和可选参数不同的是，默认参数可以不放在函数入参的最后面，

```ts
function add(x: number = 100, y: number): number {
  return x + y;
}

add(100);
```

看上面的代码，add 函数只传了一个参数，如果理所当然地觉得 x 有默认值，只传一个就传的是 y 的话，就会报错，

![image.png](imgs/1af1b96a730744d2a7d2f84c4b0654f1_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

编译器会判定你只传了 x，没传 y。

如果带默认值的参数不是最后一个参数，用户必须明确的传入 `undefined`值来获得默认值。

```ts
add(undefined, 100); // 200
```

### 函数赋值

JS 中变量随便赋值没问题，

![image.png](imgs/f38d740b30654308bdc21a91f916657a_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

但在 TS 中函数不能随便赋值，会报错的，

![image.png](imgs/fcf70c88bc3f4cef974b052d03ca6cfe_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

也可以用下面这种方式定义一个函数 add3，把 add2 赋值给 add3

```Typescript
let add2 = (x: number, y: number): number => {
    return x + y
}

const add3:(x: number, y: number) => number = add2
```

(x: number, y: number) => number ，有点像 es6 中的箭头函数，但不是箭头函数，TS 遇到 `:` 就知道后面的代码是写类型用的。

当然，不用定义 add3 类型直接赋值也可以，TS 会在变量赋值的过程中，自动推断类型，如下图：

![image.png](imgs/f12e8591e7a54e5895265af2d9db6ad8_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### 无返回值

函数没有明确返回值，默认返回 Void 类型

```Typescript
function welcome(): void {
    console.log('hello');
}
```

`void`类型表示没有返回值

返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。

# 十一、interface 接口类型

`interface` 接口类型用来，描述一个对象的类型（注解对象类型）

一般当一个**对象类型被多次使用**时，一会使用 interface 来描述对象的类型，达到**复用**的目的

### 基本概念

`interface`(接口) 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。

interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。

这是 ts 新增的一种概念，类似咱们的电脑，任何的电脑，都有 usb 接口，usb 接口就是一种统一的规范，只要实现了 usb 接口的电脑，都可以使用 usb 线连接其他设备。简单说接口是一个规范和约定，约定了要有哪些属性和方法。

定义 interface 一般首字母大写，以大写的 I 开头代码如下：

```Typescript
interface IPerson {
  firstName: string;
  lastName: string;
  age: number;
  sum: (a: number, b: number) => number;
  sing(songName: string): string;
}
```

上面示例中，定义了一个接口`IPerson`，它指定一个对象模板，拥有三个属性`firstName`、`lastName`和`age`，两个方法。任何实现这个接口的对象，都必须部署这三个属性和两个方法，并且必须符合规定的类型。

声明接口以后，可以直接使用**接口名称作为变量的类型**

实现该接口很简单，只要指定它作为对象的类型即可。

```
let obj: IPerson = {
  firstName: "james",
  lastName: "watt",
  age: 18,
  sum(a, b) {
    return a + b;
  },
  sing(songName) {
    return "结束";
  },
};
```

属性必须和类型定义的时候完全一致。

少写了属性，报错：

多写了属性，报错：

类型提示，显著提升开发效率：

![1701133719260](imgs/1701133719260.png)

> 注意：interface 不是 JS 中的关键字，所以 TS 编译成 JS 之后，这些 interface 是不会被转换过去的，都会被删除掉，interface 只是在 TS 中用来做静态检查。

###

### 可选属性？

跟函数的可选参数是类似的，在属性上加个 `?`，这个属性就是可选的，比如下面的 age 属性

```JavaScript
interface Person {
    name: string;
    age?: number;
}

const p1: Person = {
    name: 'lin',
}
```

### 只读属性 readonly

如果希望某个属性不被改变，可以这么写：

```Typescript
interface Person {
    readonly id: number
    name: string
    age: number
}
```

改变这个只读属性时会报错。

![image.png](imgs/9af37cf08f264d16a46b2d3d3e49b7f7_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### interface 描述函数类型

interface 也可以用来描述函数类型，代码如下：

```Typescript
interface ISum {
    (x:number,y:number):number
}

const add:ISum = (num1, num2) => {
    return num1 + num2
}
```

### 自定义属性

上文中，对象的属性必须和接口中定义的类型定义的时候完全一致，如果一个对象上有多个不确定的属性，怎么办？

可以这么写。

```Typescript
interface RandomKey {
    [propName: string]: string
}
//propName 写成什么都行

//下面在定义对象的时候，obj注解了RandomKey类型，对象里面的属性名就可以任意的，属性值必须是字符串
const obj: RandomKey = {
    a: 'hello',
    b: 'lin',
    c: 'welcome',
}
```

如果把属性名定义为 number 类型，就是一个类数组了，看上去和数组一模一样。

```Typescript
interface LikeArray {
    [propName: number]: string
}

const arr: LikeArray = ['hello', 'lin']

arr[0]  // 可以使用下标来访问值
```

当然，不是真的数组，数组上的方法它是没有的。

![image.png](imgs/d2d1d0c8ad32482ba8108c8e2463df19_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### 接口间的继承

如果两个接口之间有相同属性或者方法，可以将公有的属性或方法抽离出来，可以通过继承来实现复用。

比如，两个接口都是描述一个点的，第一个是 2d 点的有 x，y 属性

第二个是 3d 点，有 x，y,z 属性，可以定义两个，x，y 都重复写，但是很麻烦

```
interface Point2D {
  x: number;
  y: number;
}
interface Point3D  {
  x: number;
  y: number;
  z: number;
}
```

通过继承

```
interface Point2D {
  x: number;
  y: number;
}
interface Point3D extends Point2D {
  z: number;
}
```

继承以后，3d 接口就有了 2d 接口的 属性和方法

## 接口的典型应用场景

1-前端调用后端的接口，很多时候接口的参数名字是固定的，我们就可以使用接口的描述，防止我们调用接口传参错误

2- 后端返回的数据，一般直接使用是没有类型提示的，我们可以定义接口来注解返回的数据，然后使用的时候就获取了类型提示，防止使用属性名错误

# 十二、type 注解对象

除了使用 interface 来注解对象，也可以使用 type 注解对象的类型

属性的类型可以用分号结尾，也可以用逗号结尾。

```
// 属性类型以分号结尾
type MyObj = {
  x:number;
  y:number;
};

// 属性类型以逗号结尾
type MyObj = {
  x:number,
  y:number,
};
let obj:MyObj={x:1,y:2}
```

最后一个属性后面，可以写分号或逗号，也可以不写。

#### 可选属性

如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。

```
const obj: {
  x: number;
  y?: number;
} = { x: 1 };
```

上面示例中，属性`y`是可选的。

可选属性等同于允许赋值为`undefined`，下面两种写法是等效的。

```
type User = {
  firstName: string;
  lastName?: string;
};

// 等同于
type User = {
  firstName: string;
  lastName?: string|undefined;
};
```

上面示例中，类型`User`的可选属性`lastName`可以是字符串，也可以是`undefined`，即可选属性可以赋值为`undefined`。

```
const obj: {
  x: number;
  y?: number;
} = { x: 1, y: undefined };
```

上面示例中，可选属性`y`赋值为`undefined`，不会报错。

### type 配合交叉类型 &模拟继承

```
type Point2D = {
  x: number,
  y: number,
}

type Point3D  = Point2D & {
  z: number;
}
```

Point3D 类型就必须有三个属性 x，y，z

### interface（接口）和 type（类型别名）比较：

- 相同点：都可以给对象类型指定类型
- 不同点：
  - 接口，只能为对象类型指定类型
  - 类型别名，不仅可以为对象指定类型，也可以为任意的类型指定别名

### 练习：尝试使用 type 给服务器返回的数据注解类型

服务器返回数据如下,注意返回的数据是一个嵌套结构的对象

```
{
  code: 1,
  msg: "发布成功",
  data: {
    title: "你好明天",
    content: "测试一下",
  },
};
```

答案

```
type resType = {
  code: number;
  msg: string;
  data: {
    title: string;
    content: string;
  };
};

//使用接口也可以
interface resType2 {
  code: number;
  msg: string;
  data: {
    title: string;
    content: string;
  };
}


```

# 十三：字面量类型

字面量类型就是使用 js 中的值作为类型去注解

```
let age:100;
```

表示 age 只能赋值为 100

```
let name :"apple"|"orange"
```

表示 name 只是是 apple 或者 orange

# 十四、类型推论

类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。

```
let foo = 123;
```

上面示例中，变量`foo`并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为`number`。

后面，如果变量`foo`更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。

```
let foo = 123;
foo = 'hello'; // 报错
```

上面示例中，变量`foo`的类型推断为`number`，后面赋值为字符串，TypeScript 就报错了。

TypeScript 也可以推断函数的返回值。

```
function toString(num:number) {
  return String(num);
}
```

上面示例中，函数`toString()`没有声明返回值的类型，但是 TypeScript 推断返回的是字符串。正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。

 从这里可以看到，TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证 TypeScript 会正确推断出类型。由于这个原因，所有 JavaScript 代码都是合法的 TypeScript 代码。

 这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。

## 建议

 1-使用 ts 开发时候类型注解就省略能省略。（提高开发效率，使用默认的类型推论。最近很多库的开发者放弃了 ts，因为编写类型声明，太麻烦了）

 2-如果使用我们封装一个库或者框架（尽量注解类型，防止错误，别人使用起来方便）

 3-刚学 ts 的时候，尽量都加上类型注解

# 十五、any 类型

any 类型为 ts 新增的特殊类型

#### 基本含义

any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。

```
let x:any;

x = 1; // 正确
x = 'foo'; // 正确
x = true; // 正确
```

上面示例中，变量`x`的类型是`any`，就可以被赋值为任意类型的值。

 变量类型一旦设为`any`，TypeScript 实际上会关闭这个变量的类型检查。**即使有明显的类型错误，只要句法正确，都不会报错。**

```
let x:any = 'hello';

x(1) // 不报错
x.foo = 100; // 不报错
```

上面示例中，变量`x`的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，Ty**peScript 编译时都不报错。原因就是`x`的类型是`any`，TypeScript 不对其进行类型检查。**

 由于这个原因，应该尽量避免使用`any`类型，否则就失去了使用 TypeScript 的意义。（有很多开发者实际开发的时候用 any）

 实际开发中，`any`类型主要适用以下两个场合。

（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为`any`。

（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为`any`。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上`any`，TypeScript 编译时就不会报错。

总之，TypeScript 认为，只要开发者使用了`any`类型，就表示开发者想要自己来处理这些代码，所以就不对`any`类型进行任何限制，怎么使用都可以。

从集合论的角度看，`any`类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。

# 十六、类型断言

## 类型断言 as

使用类型断言来告诉 TS，我（开发者）比你（编译器）更清楚这个参数是什么类型，断言为什么类型，就可以使用这个类型的属性或者是方法，编译的时候你就别给我报错了

类型断言语法：

```TypeScript
值 as 类型
let box  = document.querySelector("#box") as Element;
```

## 断言 HTML 元素

典型的一种情况 方法的返回值返回了联合类型

比如页面中有一个 id 为 box 的 div，我们用 querySelector 方法获取了这个元素，但是这个方法返回的是 Element || null 这样一个联合类型，我们贸然去使用他们的 innerHTML 属性编辑器就会报错。

![1701136463538](imgs/1701136463538.png)

```
let box = document.querySelector("#box");
box.innerHTML = "a";//这样写就会报错 因为返回的可能是null
```

![1701136497528](imgs/1701136497528.png)

**这样就必须使用类型断言了（这个时候我们开发者已经知道他返回的类型是一个 div 了**）

在调用函数的后面 （值的后面）使用 as 断言 返回值为 Element 就可以，这样使用 innerHTML 就不会报错

```
let box = document.querySelector("#box") as Element;
box.innerHTML = 'hello';
```

如果获取的是 a 标签

```
let a = document.querySelector("a") as Element;
a.href = "aa";//断言为 Element，使用href属性 还是会报错
```

断言为精确的类型 HTMLAnchorElement ,才能使用 href 属性

```
let testa = document.querySelector("a") as HTMLAnchorElement;
testa.href = "aa";
```

当然我们也可以直接把变量声明为 any 类型，也不会报错

```
let testa: any = document.querySelector("a");
testa.href = "aa";
```

ps：很多方法的返回值的类型其实我们不知道，这也是为什么很多人喜欢用 any

## 类型断言的注意事项

断言只能告诉编辑器，变量的值是这个类型， 避免编译时出错。但是如果实际的值类型和我们断言的不一样，运行时还会出错，这就需要我们写代码时候严谨一些。

```
// 函数的参数我们定义成可以是字符串也可以是数字
function test(v: string | number) {
  // 使用v的时候，我们直接断言成字符串，然后使用字符串的方法
  // 如果调用test函数传入的字符串，运行时不会报错
  // 如果调用test函数传入的数字，这时运行时就会报错
  let res = (v as string).trim();
  return res;
}
test("hello");
test(123);//运行时报错
```

那怎么办呢，只能写代码多做判断，防止报错

```
function test(v: string | number) {

    let res = (v as string).trim();
    //断言后做判断，v是否有length属性，因为字符串有length属性
    if ((v as string).length) {
      return (v as string).trim();
    } else {
      return v;
    }
}
```

或者使用 typeof 关键字，进行类型缩小判断也行

```
function test(v: string | number) {
	//这里我们不断言了，直接使用type判断 ，进行类型缩小，类型缩小以后也是可以正常使用 某个类型的方法
  if (typeof v == "string") {
    return v.trim();
  } else if (typeof v == "number") {
    return v;
  }
  return res;
}
```

# 十七、泛型

## 什么是泛型

 泛型是指在定义函数、接口等类型的时候，不预先指定具体的类型，而是在使用的时候再指定具体类型的一种特性。

### 为什么需要泛型？

 简单来说，使用泛型可以复用类型，让类型更加灵活。

如果你看过 TS 文档，一定看过这样两段话：

> 软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。
>
> **在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。**

简直说的就不是人话，你确定初学者看得懂？

我觉得初学者应该要先明白为什么需要泛型这个东西，它解决了什么问题？而不是看这种拗口的定义。

## 来个例子

我们还是先来看这样一个例子，体会一下泛型解决的问题吧。

定义一个 print 函数，这个函数的功能是把传入的参数打印出来，再返回这个参数，传入参数的类型是 string，函数返回类型为 string。

```TypeScript
function print(arg:string):string {
    console.log(arg)
    return arg
}
```

现在需求变了，我还需要打印 number 类型，怎么办？

可以使用联合类型来改造：

```TypeScript
function print(arg:string | number):string | number {
    console.log(arg)
    return arg
}
```

现在需求又变了，我还需要打印 string 数组、number 数组，甚至任何类型，怎么办？

有个笨方法，支持多少类型就写多少联合类型。

或者把参数类型改成 any。

```TypeScript
function print(arg:any):any {
    console.log(arg)
    return arg
}
```

且不说写 any 类型不好，毕竟在 TS 中尽量不要写 any。

而且这也不是我们想要的结果，只能说传入的值是 any 类型，输出的值是 any 类型，传入和返回**并不是统一的**。

这么写甚至还会出现 bug

```TypeScript
const res:string = print(123)
```

定义 string 类型来接收 print 函数的返回值，返回的是个 number 类型，TS 并不会报错提示我们。（实际运行却可能会报错）

 这个时候，泛型就出现了，它可以轻松解决**输入输出要一致**的问题。

> 注意：泛型不是为了解决这一个问题设计出来的，泛型还解决了很多其他问题，这里是通过这个例子来引出泛型。

## 函数中使用泛型（泛型函数）

我们使用泛型来解决上文的问题。

泛型的语法是 在函数名后使用 `<>` 里写类型参数，一般可以用 `T` 来表示。

语法

```
function fn<T>(arg:T){}
```

这个时候 T 表示某个类型，后面在定义形参的类型的时候，我们可以使用 T

同理后面给函数返回值定义类型的时候也可以使用 T 表示类型

```TypeScript
function print<T>(arg:T):T {
    console.log(arg)
    return arg
}
```

具体 T 类型是什么类型，我们可以在调用函数时候指定！

调用的时候就可以这样调用（在调用的时候，我们给泛型传入了一个具体的类型）

```
print<string>("hello");
print<number>(1);
```

这样，我们就做到了输入和输出的类型统一，且可以输入输出任何类型。

如果类型不统一，就会报错：

![image.png](imgs/c4411b32b4414c8585892199cd8cd9f8_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

泛型中的 T 就像一个占位符、或者说一个变量，在使用的时候可以把定义的类型**像参数一样传入**，它可以**原封不动地输出**。

> 泛型的写法对前端工程师来说是有些古怪，比如 `<>` `T` ，但记住就好，只要一看到 `<>`，就知道这是泛型。

我们在使用的时候其实可以有两种方式指定类型。

- 定义要使用的类型
- TS 类型推断，自动推导出类型

```TypeScript
print<string>('hello')  // 定义 T 为 string

print('hello')  // TS 类型推断，自动推导类型为 string
```

## 泛型的本质

泛型其实像是 在定义类型的时候，给类型传了一个参数，参数是变的，让定义的类型，更加容易复用！

## 接口中使用泛型（泛型接口）

接口写法回顾

先用一个例子回忆一些接口的写法！

前后端交互的时候，服务器会返回数据，比如有两个接口，返回数据如下

获取用户信息接口

```
{
	code:1,
	msg:"获取用户信息成功",
	data:{
		uid:1,
		username:"zhangsan"
	}
}
```

获取商品信息接口

```
{
	code:1,
	msg:"获取商品信息成功",
	data:{
		pid:1,
		pname:"问界M7"
	}
}
```

这个时候我们需要定义几个接口来注解对象呢? 四个

```
// 用户数据-接口
interface UserData {
  uid: number;
  username: string;
}
// 服务器返回数据-接口1
interface ResData1 {
  code: number;
  msg: string;
  data: UserData;
}
// 商品数据-接口
interface GoodsData {
  pid: number;
  pname: string;
}
// 服务器返回数据-接口2
interface ResData2 {
  code: number;
  msg: string;
  data: GoodsData;
}
//变量获取数据的时候，使用泛型注解对象的类型
let r1: ResData1 = {
  code: 1,
  msg: "获取用户信息成功",
  data: {
    uid: 1,
    username: "zhangsan",
  },
};
let r2: ResData2 = {
  code: 1,
  msg: "获取商品信息成功",
  data: {
    pid: 1,
    pname: "问界M7",
  },
};

```

这里我们会发现，服务器返回 ResData1 接口和 ResData2 接口有很多地方重复了!!!!

这时我们可以使用泛型接口，来增加复用性，简单代码书写。

写一个 resData 就可以了，给接口名称后面加个泛型 T，接口里面的 data 属性的类型也用 T

```
// 用户数据-接口
interface UserData {
  uid: number;
  username: string;
}
// 商品数据-接口
interface GoodsData {
  pid: number;
  pname: string;
}
// 服务器返回数据-接口
interface ResData<T> {
  code: number;
  msg: string;
  data: T;
}

```

使用变量保存数据的时候就可以 复用 ResData 接口，传入不同的泛型就可以

```
let r1: ResData<UserData> = {
  code: 1,
  msg: "获取用户信息成功",
  data: {
    uid: 1,
    username: "zhangsan",
  },
};
let r2: ResData<GoodsData> = {
  code: 1,
  msg: "获取商品信息成功",
  data: {
    pid: 1,
    pname: "问界M7",
  },
};
```

## type 使用泛型（泛型别名）

语法：在 type 类型别名后面使用<T> 声明一个泛型参数 T，type 后面的{} 里面都可以使用这个 T 参数

```
type ResData<T> = {
	code:number,
	msg:sting,
	data:T
}
```

把上个例子中的接口都是用 type 重写

```

// 用户数据-类型
type UserData = {
  uid: number;
  username: string;
};
// 商品数据-类型
type GoodsData = {
  pid: number;
  pname: string;
};
// 服务器返回数据-类型
type ResData<T> = {
  code: number;
  msg: string;
  data: T;
};

let r1: ResData<UserData> = {
  code: 1,
  msg: "获取用户信息成功",
  data: {
    uid: 1,
    username: "zhangsan",
  },
};
let r2: ResData<GoodsData> = {
  code: 1,
  msg: "获取商品信息成功",
  data: {
    pid: 1,
    pname: "问界M7",
  },
};

```

# 十八、泛型约束

使用场景： 我们知道泛型的特点是灵活不确定，传入什么类型就是什么类型。但是！有些时候，在函数内使用泛型的时候需要访问某些特定类型才具有的属性，此时会有类型错误，需要通过泛型约束来解决这个报错！

### 约束泛型

假设现在有这么一个函数，打印传入参数的长度，我们这么写：

```TypeScript
function printLength<T>(arg: T): T {
    console.log(arg.length)
    return arg
}
```

因为不确定 T 是否有 length 属性，会报错：

![image-20240225232349421](imgs/image-20240225232349421.png)

那么现在我想约束这个泛型，一定要有 length 属性，怎么办？

可以和 interface 结合，来约束类型。

我们先定义一个接口，描述对象有 length 属性

```TypeScript
interface ILength {
    length: number
}
```

然后让泛型 T 继承 ILength 接口 ,这样就限制了（约束）T 必须有 length 属性！

```
function printLength<T extends ILength>(arg: T): T {
    console.log(arg.length)
    return arg
}
```

**这其中的关键就是 `<T extends ILength>`，让这个泛型继承接口 `ILength`，这样就能约束泛型。**

我们定义的变量一定要有 length 属性，比如下面的 str、arr 和 obj，才可以通过 TS 编译。

```ts
const str = printLength("lin");
const arr = printLength([1, 2, 3]);
const obj = printLength({ length: 10 });
```

只要你有 length 属性，都符合约束，那就不管你是 str，arr 还是 obj，都没问题。

当然，我们定义一个不包含 length 属性的变量，比如数字，就会报错：

![image.png](imgs/0a8261afe4e7429a804c980d3c1eede7_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### 泛型约束的作用

保留泛型的灵活性，同时限制了泛型中属性

### 泛型小结

`泛型`（Generics），从字面上理解，泛型就是一般的，广泛的。

泛型是指在定义函数、接口或类的时候，不预先指定具体类型，而是在使用的时候再指定类型。

泛型中的 `T` 就像一个占位符、或者说一个变量，在使用的时候可以把定义的类型**像参数一样传入**，它可以**原封不动地输出**。

泛型也可以被约束！

#### 泛型的好处：

 1-增加了类型的复用性和灵活性

 2-泛型约束，保留泛型的灵活性，同时限制了泛型中属性

#### 泛型的使用：

 1=找到类型中不确定的部分，定义成泛型参数

 2-使用类型的时候，传入泛型参数的值

# 十九、枚举

在任何项目开发中，我们都会遇到定义常量的情况，常量就是指不会被改变的值。

TS 中我们使用 `const` 来声明常量，但是有些取值是在一定范围内的一系列常量，比如一周有七天，比如方向分为上下左右四个方向。

这时就可以使用枚举（Enum）来定义。

### 基本使用

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
```

这样就定义了一个**数字枚举**，他有两个特点：

- 数字递增
- 反向映射

枚举成员会被赋值为从 `0` 开始递增的数字，

```ts
console.log(Direction.Up); // 0
console.log(Direction.Down); // 1
console.log(Direction.Left); // 2
console.log(Direction.Right); // 3
```

枚举会对枚举值到枚举名进行反向映射，

```ts
console.log(Direction[0]); // Up
console.log(Direction[1]); // Down
console.log(Direction[2]); // Left
console.log(Direction[3]); // Right
```

如果枚举第一个元素赋有初始值，就会从初始值开始递增，

```ts
enum Direction {
  Up = 6,
  Down,
  Left,
  Right,
}

console.log(Direction.Up); // 6
console.log(Direction.Down); // 7
console.log(Direction.Left); // 8
console.log(Direction.Right); // 9
```

### 手动赋值

定义一个枚举来管理外卖状态，分别有已下单，配送中，已接收三个状态。

可以这么写，

```ts
enum ItemStatus {
  Buy = 1,
  Send,
  Receive,
}

console.log(ItemStatus["Buy"]); // 1
console.log(ItemStatus["Send"]); // 2
console.log(ItemStatus["Receive"]); // 3
```

但有时候后端给你返回的数据状态是乱的，就需要我们手动赋值。

比如后端说 Buy 是 100，Send 是 20，Receive 是 1，就可以这么写，

```ts
enum ItemStatus {
  Buy = 100,
  Send = 20,
  Receive = 1,
}

console.log(ItemStatus["Buy"]); // 100
console.log(ItemStatus.Buy); // 100
console.log(ItemStatus["Send"]); // 20
console.log(ItemStatus["Receive"]); // 1
```

实际开发中经常会有这种情况发生。

### 字符串枚举

字符串枚举的意义在于，提供有具体语义的字符串，可以更容易地理解代码和调试。

```ts
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}

const value = "UP";
if (value === Direction.Up) {
  // do something
}
```

### 常量枚举

上文的例子，使用 const 来定义一个常量枚举

```ts
const enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}

const value = "UP";
if (value === Direction.Up) {
  // do something
}
```

编译出来的 JS 代码会简洁很多，提高了性能。

```js
const value = "UP";
if (value === "UP") {
  // do something
}
```

不写 const 编译出来是这样的，

```js
var Direction;
(function (Direction) {
  Direction["Up"] = "UP";
  Direction["Down"] = "DOWN";
  Direction["Left"] = "LEFT";
  Direction["Right"] = "RIGHT";
})(Direction || (Direction = {}));
const value = "UP";
if (value === Direction.Up) {
  // do something
}
```

这一堆定义枚举的逻辑会在编译阶段会被删除，常量枚举成员在使用的地方被内联进去。

### 小结

枚举的意义在于，可以定义一些带名字的常量集合，清晰地表达意图和语义，更容易地理解代码和调试。

常用于和后端联调时，区分后端返回的一些代表状态语义的数字或字符串，降低阅读代码时的心智负担。

# 二十、类

我们知道， JS 是靠原型和原型链来实现面向对象编程的，es6 新增了语法糖 class。

TS 通过 `public`、`private`、`protected` 三个修饰符来增强了 JS 中的类。

在 TS 中，写法和 JS 差不多，只是要定义一些类型而已，我们通过下面几个例子来复习一下类的封装、继承和多态。

### 基本写法

定义一个 Person 类，有属性 name 和 方法 speak

```Typescript
class Person {
    name: string
    constructor(a: string) {
        this.name = a
    }
    speak() {
        console.log(`${this.name} is speaking`)
    }
}

const p1 = new Person('lin')      // 新建实例

p1.name                           // 访问属性和方法
p1.speak()
```

如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。

```
class Point {
  x = 0;
  y = 0;
}
```

上面示例中，属性`x`和`y`的类型都会被推断为 number。

### readonly 修饰符

属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。

```
class A {
  readonly id = 'foo';
}

const a = new A();
a.id = 'bar'; // 报错
```

上面示例中，`id`属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。

readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。

```
class A {
  readonly id:string;

  constructor() {
    this.id = 'bar'; // 正确
  }
}
```

上面示例中，构造方法内部设置只读属性的初值，这是可以的。

```
class A {
  readonly id:string = 'foo';

  constructor() {
    this.id = 'bar'; // 正确
  }
}
```

上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。

### 方法的类型

类的方法就是普通函数，类型声明方式与函数一致。

```
class Point {
  x:number;
  y:number;

  constructor(x:number, y:number) {
    this.x = x;
    this.y = y;
  }

  add(point:Point) {
    return new Point(
      this.x + point.x,
      this.y + point.y
    );
  }
}
```

上面示例中，构造方法`constructor()`和普通方法`add()`都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。

### 存取器方法

存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。

它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。

```
class C {
  _name = "";
  get name() {
    console.log("get name会执行");

    return this._name;
  }
  set name(value) {
    console.log("set name会执行");
    this._name = value;
  }
}

let t1 = new C();
t1.name = "aa";
console.log(t1.name);
```

上面示例中，`get name()`是取值器，其中`get`是关键词，`name`是属性名。外部读取`name`属性时，实例对象会自动调用这个方法，该方法的返回值就是`name`属性的值。

`set name()`是存值器，其中`set`是关键词，`name`是属性名。外部写入`name`属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。

### 继承

使用 extends 关键字实现继承，定义一个 Student 类继承自 Person 类。

```Typescript
class Student extends Person {
    study() {
        console.log(`${this.name} needs study`)
    }
}

const s1 = new Student('lin')

s1.study()
```

继承之后，Student 类上的实例可以访问 Person 类上的属性和方法。

![image.png](imgs/158044956a9c40e2bdeedceb95d4ae93_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

#### super 关键字

注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。

比如，Student 类新增一个 grade(成绩) 属性，就要这么写：

```Typescript
class Student extends Person {
    grade: number
    constructor(name: string,grade:number) {
        super(name)
        this.grade = grade
    }
}

const s1 = new Student('lin', 100)
```

不写 super 会报错。

![image.png](imgs/5c1e980ba499474dba266e77849b5018_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

## 可访问性修饰符

类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：`public`、`private`和`protected`。

这三个修饰符的位置，都写在属性或方法的最前面。

### public

`public`，公有的，一个类里默认所有的方法和属性都是 public。

比如上文中定义的 Person 类，其实是这样的：

```Typescript
class Person {
    public name: string
    public constructor(name: string) {
        this.name = name
    }
    public speak() {
        console.log(`${this.name} is speaking`)
    }
}
```

public 可写可不写，不写默认也是 public。

### private

`private`，私有的，只属于这个类自己，它的实例和继承它的子类都访问不到。

将 Person 类的 name 属性改为 private。

```Typescript
class Person {
    private name: string
    public constructor(name: string) {
        this.name = name
    }
    public speak() {
        console.log(`${this.name} is speaking`)
    }
}
```

实例访问 name 属性，会报错：

![image.png](imgs/7581d7192dcb455fbe5c9214c607c812_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

继承它的子类 访问 name 属性，会报错：

![image.png](imgs/b5958c9761864a64b90a21f36f150061_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### protected

`protected` 受保护的，继承它的子类可以访问，实例不能访问。

将 Person 类的 name 属性改为 protected。

```Typescript
class Person {
    protected name: string
    public constructor(name: string) {
        this.name = name
    }
    public speak() {
        console.log(`${this.name} is speaking`)
    }
}
```

实例访问 name 属性，会报错：

![image.png](imgs/2b95b64b33814957b177d15858b1a0bc_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

子类可以访问。

```Typescript
class Studeng extends Person {
    study() {
        console.log(`${this.name} needs study`)
    }
}
```

### 实例属性的简写形式

实际开发中，很多实例属性的值，是通过构造方法传入的。

```
class Point {
  x:number;
  y:number;

  constructor(x:number, y:number) {
    this.x = x;
    this.y = y;
  }
}
```

上面实例中，属性`x`和`y`的值是通过构造方法的参数传入的。

这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。

```
class Point {
  constructor(
    public x:number,
    public y:number
  ) {
  
  }
}

const p = new Point(10, 10);
p.x // 10
p.y // 10
```

上面示例中，**构造方法的参数`x`前面有`public`修饰符**，这时 TypeScript 就会自动声明一个公开属性`x`，不必在构造方法里面写任何代码，同时还会设置`x`的值为构造方法的参数值。注意，这里的`public`不能省略。

## static

`static` 是静态属性，可以理解为是类上的一些常量，实例不能访问。

比如一个 Circle 类，圆周率是 3.14，可以直接定义一个静态属性。

```Typescript
class Circle {
    static pi = 3.14
    public radius: number
    public constructor(radius: number) {
        this.radius = radius
    }
    public calcLength() {
        return Circle.pi * this.radius * 2  // 计算周长，直接访问 Circle.pi
    }
}
```

实例访问，会报错：

![image.png](imgs/8d7b5894179c4f6c87ca9f48a796d16f_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

## 抽象类

抽象类，听名字似乎是非常难理解的概念，但其实非常简单。

TS 通过 `public`、`private`、`protected` 三个修饰符来增强了 JS 中的类。

其实 TS 还对 JS 扩展了一个新概念——`抽象类`。

所谓抽象类，是指**只能被继承，但不能被实例化的类**，就这么简单。

抽象类有两个特点：

- 抽象类不允许被实例化
- 抽象类中的抽象方法必须被子类实现

抽象类用一个 `abstract` 关键字来定义，我们通过两个例子来感受一下抽象类的两个特点。

#### 抽象类不允许被实例化

```ts
abstract class Animal {}

const a = new Animal();
```

定义一个抽象类 Animal，初始化一个 Animal 的实例，直接报错，

![image.png](imgs/f8ced0f9c76a40d884c1b9fd88cf6703_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

#### 抽象类中的抽象方法必须被子类实现

```ts
abstract class Animal {
  constructor(name: string) {
    this.name = name;
  }
  public name: string;
  public abstract sayHi(): void;
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
}
```

定义一个 Dog 类，继承自 Animal 类，但是却没有实现 Animal 类上的抽象方法 `sayHi`，报错，

![image.png](imgs/a3848210637e4f44a6b54bdfd68048d5_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

正确的用法如下，

```ts
abstract class Animal {
  constructor(name: string) {
    this.name = name;
  }
  public name: string;
  public abstract sayHi(): void;
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
  public sayHi() {
    console.log("wang");
  }
}
```

#### 为什么叫抽象类？

很显然，抽象类是一个广泛和抽象的概念，不是一个实体，就比如上文的例子，动物这个概念是很广泛的，猫、狗、狮子都是动物，但动物却不好是一个实例，实例只能是猫、狗或者狮子。

官方一点的说法是，在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

比如 Animal 类只是具有动物都有的一些属性和方法，但不会具体到包含猫或者狗的属性和方法。

所以抽象类的用法是用来定义一个基类，声明共有属性和方法，拿去被继承。

抽象类的好处是可以抽离出事物的共性，有利于代码的复用。

#### 抽象方法和多态

多态是面向对象的三大基本特征之一。

多态指的是，父类定义一个抽象方法，在**多个子类中有不同的实现**，运行的时候不同的子类就对应不同的操作，比如，

```ts
abstract class Animal {
  constructor(name: string) {
    this.name = name;
  }
  public name: string;
  public abstract sayHi(): void;
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
  public sayHi() {
    console.log("wang");
  }
}

class Cat extends Animal {
  constructor(name: string) {
    super(name);
  }
  public sayHi() {
    console.log("miao");
  }
}
```

Dog 类和 Cat 类都继承自 Animal 类，Dog 类和 Cat 类都不同的实现了 sayHi 这个方法。

### this 类型

接下来，我们介绍一种特殊的类型，this 类型。

类的成员方法可以直接返回一个 `this`，这样就可以很方便地实现链式调用。

#### 链式调用

```ts
class StudyStep {
  step1() {
    console.log("listen");
    return this;
  }
  step2() {
    console.log("write");
    return this;
  }
}

const s = new StudyStep();

s.step1().step2(); // 链式调用
```

#### 灵活调用子类父类方法

在继承的时候，this 可以表示父类型，也可以表示子类型

```ts
class StudyStep {
  step1() {
    console.log("listen");
      this.step2()
    return this;
  }
  step2() {
    console.log("write");
    return this;
  }
}

class MyStudyStep extends StudyStep {
    
  next() {
    console.log("before done, study next!");
      this.step2()
    return this;
  }
}

const m = new MyStudyStep();

m.step1().next().step2().next(); // 父类型和子类型上的方法都可随意调用
```

这样就保持了父类和子类之间接口调用的连贯性

## interface 和 class 的关系

上文中我们说过，interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。

interface 同样可以用来约束 class，要实现约束，需要用到 `implements` 关键字。

### implements 实现

implements 是实现的意思，class 实现 interface。

比如手机有播放音乐的功能，可以这么写：

```Typescript
interface MusicInterface {
    playMusic(): void
}

class Cellphone implements MusicInterface {
    playMusic() {}
}
```

定义了约束后，class 必须要满足接口上的所有条件。

如果 Cellphone 类上不写 playMusic 方法，会报错。

![image.png](imgs/8764d5bcdd794de99d4d88aa7e5bfc7d_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

### 应用场景：处理公共的属性和方法

不同的类有一些共同的属性和方法，使用继承很难完成。

比如汽车（Car 类）也有播放音乐的功能，你可以这么做：

- 用 Car 类继承 Cellphone 类
- 找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类

很显然这两种方法都不合常理。

实际上，使用 implements，问题就会迎刃而解。

```Typescript
interface MusicInterface {
    playMusic(): void
}

class Car implements MusicInterface {
    playMusic() {}
}

class Cellphone implements MusicInterface {
    playMusic() {}
}
```

这样 Car 类和 Cellphone 类都约束了播放音乐的功能。

再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。

```Typescript
interface MusicInterface {
    playMusic(): void
}

interface CallInterface {
    makePhoneCall(): void
}

class Cellphone implements MusicInterface, CallInterface {
    playMusic() {}
    makePhoneCall() {}
}
```

这个 CallInterface 也可以用于 iPad 类、手表类上面，毕竟他们也能打电话。

interface 来约束 class，只要 class 实现了 interface 规定的属性或方法，就行了，没有继承那么多条条框框，非常灵活。

## Class 类型

### 实例类型

TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。

```
class Color {
  name:string;

  constructor(name:string) {
    this.name = name;
  }
}

const green:Color = new Color('green');
```

上面示例中，定义了一个类`Color`。它的类名就代表一种类型，实例对象`green`就属于该类型。

对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。

```
interface MotorVehicle {
}

class Car implements MotorVehicle {
}

// 写法一
const c1:Car = new Car();
// 写法二
const c2:MotorVehicle = new Car();
```

上面示例中，变量的类型可以写成类`Car`，也可以写成接口`MotorVehicle`。它们的区别是，如果类`Car`有接口`MotoVehicle`没有的属性和方法，那么只有变量`c1`可以调用这些属性和方法。

### 类的自身类型

要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。

```
function createPoint(
  PointClass:typeof Point,
  x:number,
  y:number
):Point {
  return new PointClass(x, y);
}
```

上面示例中，`createPoint()`的第一个参数`PointClass`是`Point`类自身，要声明这个参数的类型，简便的方法就是使用`typeof Point`。因为`Point`类是一个值，`typeof Point`返回这个值的类型。注意，`createPoint()`的返回值类型是`Point`，代表实例类型。

JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。

```
function createPoint(
  PointClass: new (x:number, y:number) => Point,
  x: number,
  y: number
):Point {
  return new PointClass(x, y);
}
```

上面示例中，参数`PointClass`的类型写成了一个构造函数，这时就可以把`Point`类传入。

构造函数也可以写成对象形式，所以参数`PointClass`的类型还有另一种写法。

```
function createPoint(
  PointClass: {
    new (x:number, y:number): Point
  },
  x: number,
  y: number
):Point {
  return new PointClass(x, y);
}
```

根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。

```
interface PointConstructor {
  new(x:number, y:number):Point;
}

function createPoint(
  PointClass: PointConstructor,
  x: number,
  y: number
):Point {
  return new PointClass(x, y);
}
```

总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。

# 二十一、内置类型

JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。

内置对象是指根据标准在全局作用域 `global` 上存在的对象，这里的标准指的是 `ECMAcript` 和其他环境（比如 DOM）的标准。

### JS 八种内置类型

```ts
let name: string = "lin";
let age: number = 18;
let isHandsome: boolean = true;
let u: undefined = undefined;
let n: null = null;
let obj: object = { name: "lin", age: 18 };
let big: bigint = 100n;
let sym: symbol = Symbol("lin");
```

### ECMAScript 的内置对象

比如，`Array`、`Date`、`Error` 等，

```ts
const nums: Array<number> = [1, 2, 3];

const date: Date = new Date();

const err: Error = new Error("Error!");

const reg: RegExp = /abc/;

Math.pow(2, 9);
```

以 `Array` 为例，按住 `comand/ctrl`，再鼠标左键点击一下，就能跳转到类型声明的地方。

![image.png](imgs/27e0bb7c31d7476aa6796823f1b1306b_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp)

可以看到，Array 这个类型是用 interface 定义的，有多个不同版本的 `.d.ts` 文件声明了这个类型。

在 TS 中，重复声明一个 interface，会把所有的声明全部合并，这里所有的 `.d.ts` 文件合并出来的 Array 接口，就组合成了 Array 内置类型的全部属性和功能。

再举个例子

### DOM 和 BOM

比如 `HTMLElement`、`NodeList`、`MouseEvent` 等

```ts
let body: HTMLElement = document.body;

let allDiv: NodeList = document.querySelectorAll("div");

document.addEventListener("click", (e: MouseEvent) => {
  e.preventDefault();
  // Do something
});
```













 

 

# 二十二、装饰器 ( Decorators )  

​		装饰器（Decorator）是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，装饰器的本身。其本身是一个函数，会在运行的时候被调用，被装饰的声明信息会作为参数传递给装饰器函数，当作形参。装饰器本质上主要是在操作原型对象，通过给原型对象 `prototype`添加一些方法和属性，来扩展类的功能。

​		在很多后端框架中都使用了一种anotation（注解）风格的编程方式，比如NestJS，SpringBoot。让人编写代码时感觉非常的优雅简洁。
​		另外我们也可以使用装饰器来实现AOP(Aspect Oriented Program)编程-面向切面编程


```
AOP:
在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点
```



鸿蒙开发用使用的arkts，也是基于ts的。并且用了很多的已经定义好的装饰器，这里我们主要理解装饰器使用的原理。在学习使用鸿蒙开发的时候，记住系统提供的装饰器的作用即可！！！



## 装饰器的意义 : 

 说白了, 装饰器就是一个方法(函数), 可以注入到 类, 属性, 方法 中对其进行一些扩展

让我们的一个类变得更加的多样化, 更加的完善

（装饰，就是给要装饰的东西，添加一些额外的代码，就像人戴一些首饰，帽子之类的装饰，可以带来一些额外好看，保暖之类的作用。玩过游戏的同学都知道，你传个布衣和皮甲的效果肯定不一样）

 

ts中想要使用装饰器，需要在tsconfig.json配置文件中 开启配置experimentalDecorators 和emitDecoratorMetadata为true



ts中的装饰器有两个版本的，鸿蒙arkts采用的ts5之前的装饰器语法！(也就是我们学习的装饰器语法)

要开启experimentalDecorators和 emitDecoratorMetadata 为true 为true 就可以！！

```
   "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
```

同时 修改

```
        "useDefineForClassFields": true, // 这一项的存在会影响现有的装饰器逻辑
```

将这个注释掉，这一项的存在会影响现有的装饰器逻辑









​	 装饰器主要分为类装饰器（接收1个参数）、属性装饰器（接收2个参数）、方法装饰器（接收3个参数、参数装饰器（接收3个参数），不同装饰器接收参数也不一同。另外TS内置了装饰器类型，我们直接用就好了。

​		

| 装饰器分类 | ts内置装饰器类型   | 接收参数                                |
| ---------- | ------------------ | --------------------------------------- |
| 类装饰器   | ClassDecorator     | 1个，类函数                             |
| 方法装饰器 | MethodDecorator    | 3个，类函数，方法名，成员属性描述符     |
| 属性装饰器 | PropertyDecorator  | 2个，类函数、属性名称                   |
| 参数装饰器 | ParameterDecorator | 3个，类函数，参数名，参数所在位置的索引 |



- 语法 `@expression`，`expression`是一个函数，位置根据不同类型的装饰器要求放置。





# **类的装饰器**

类装饰器，它**会在类声明时被调用**，并接收类的构造函数作为参数。

类装饰器通常用于修改或扩展类的行为，比如添加属性或者方法。

### （1）一个装饰器

#### 定义装饰器-给类添加一个方法

```
function ClassDecorator(target: Function): void {
  //target 是类本身，js中也叫构造函数	
  console.log('类装饰器被执行-给类添加了一个start方法')	
  //给类的原型添加了一个方法
  
  target.prototype.start = function (): void {
    // 通用功能
    console.log("1");
  };
}

```



使用装饰器

```
@ClassDecorator
class Course {
  constructor() {
    // 业务逻辑
  }
}
let course = new Course();
console.log("course start");
course.start()
```

我们给类，使用装饰器ClassDecorator装饰，在类定义的时候装饰器就立刻执行！

通过这个装饰器，我们实现了类似 给 类**添加方法**的功能，但是没有影响原有类！！ 有点类似于继承！

装饰了哪个类，哪个类就有这个方法！

装饰以后我们就可以使用添加的方法了



#### 修改或者多替换类内部的方法

```
function TestDe(target: Function): void {
  console.log('装饰器执行')
  //保存原来函数
  let test = target.prototype.test;
  //定义新的test
  target.prototype.test = function (): void {
    // 通用功能
    console.log("TestDe-添加的test方法");
    //这里如果不调用原来的test方法，相当于替换了原来的test方法
    test.call(this)
  };
}
@TestDe
class Course {
  constructor() {
    // 业务逻辑
  }
  test() {
    console.log("类内部本身的test方法");
  }
}
let course: any = new Course();
course.test();
```





### （2）装饰器累加-多个装饰器

装饰器不是只能定义一个，可以定义多个作用于一个类函数，通过装饰器累加从而给类追加多个方法和属性，可以用来监视、修改、替换类定义。

- 参数：只有`target`一个，意思是类函数本身

```javascript
function StartTime(target: Function): void {
    console.log('添加start方法')
  target.prototype.start = function(): void {
      // 通用功能
      console.log('start')
  }
}
function EndTime(target: Function): void {
    console.log('添加end方法')
  target.prototype.end = function(): void {
      // 通用功能
      console.log('end')
  }
}
@StartTime
@EndTime
class Course {
  constructor() {
      // 业务逻辑
  }
}
let course: any = new Course();
course.start();
course.end();
```

多个装饰器**自下而上执行**，先添加end方法，在添加start方法，





### 2）装饰器传参

装饰器也可以传参

那么怎么接受呢，参数如何放置，只需要在内部再返回一个装饰器就可，参数在外部进行接收，在装饰器函数内返回一个装饰器函数

具体例子如下所示：

```javascript
//ClassDecorator 装饰器 用来生成装饰器，也叫装饰器工厂
function ClassDecorator(name: string) {
  //返回一个装饰器函数
  return (target: any)  => {
    target.prototype.name = name
  }
}
@ClassDecorator('zhangsan')//装饰器立刻执行，并且返回一个函数，立刻调用，接收了传入的参数zhangsan
class Course {
  constructor() {
      // 业务逻辑
  }
}
let course:p = new Course();
interface p {
   name?:string
}
console.log('course',course.name)//zhangsan
```

 真正的装饰器是 ，内部返回的函数！

 



 

# **方法的装饰器**

方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 可以用来监视，修改或者替换方法

方法装饰器表达式会**在类内部定义方法的时候被调用**，传入下列3个参数：

1-对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2-成员的名字。
3-成员的属性描述符。

- target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
- propertyKey: 方法名称。
- descriptor: 成员的属性描述符。





## 定义方法装饰器

#### 日志修饰器和切面AOP

比如我们看下面代码，有一个`Maths`类，里面有各种算术函数，比如说`add`函数用来计算入参的值，但现在希望在计算和的时候，也打印出相关的日志，此时我们就可以给这个`add`函数加上一个装饰器，用来修改原本方法的功能，整体代码如下所示：

```
/**
 * 方法装饰器，在方法调用的时候会执行
 * @param target 这里就是Maths的实例
 * @param name 成员的名称
 * @param descriptor 成员属性描述符
 */
const log = (target, name, descriptor) => {
  console.log('target：', target);
  console.log('name：', name);
  console.log('descriptor：', descriptor);
}

class Maths {
  // @log是一个装饰器函数，用来修饰add函数
  @log
  add (num1: number, num2: number) {
    return num1 + num2
  }
}
const math = new Maths()
math.add(2, 3);
```

log装饰器会在类定义的时候就执行。

我们在调用add函数的时候，其实不会执行装饰器里面的任何代码。



属性描述符

通过上面我们可以看到，前两个参数比较容易理解，分别表示对应的构造函数/实例，或者是成员名称，第三个descriptor成员描述符有下面几个属性

value：该成员名称对应的值，这里就是add函数定义
writable：是否可写
enumerable：是否可枚举
configurable：是否可配置
我们可以通过value来复写原本的函数功能，

接下来我们在装饰器里面做一个拦截（监听），实现日志打印功能。

```
/**
 * 装饰器
 * @param target 这里就是Maths的实例
 * @param name 成员的名称
 * @param descriptor 成员属性描述符
 */
const log = (target, name, descriptor) => {
  console.log("target：", target);
  console.log("name：", name);
  console.log("descriptor：", descriptor);

  // 保存之前的值--就是原来的add函数
  const oldValue = descriptor.value;
  // 覆盖原来的老值-等于说定了了一个新的函数add -是替换了原来的add函数
  descriptor.value = (...args) => {
    //添加打印逻辑
    console.log(`${name}被调用，入参为: ${args}`);
    // 使用原来的函数调用 
    return oldValue.apply(null, args);
  };
};

class Maths {
  // @log是一个装饰器函数，用来修饰add函数
  @log
  add(num1: number, num2: number) {
    return num1 + num2;
  }
}
const math = new Maths();
math.add(2, 3);

```

等于说是拦截了原来函数的执行，添加了一些自己的逻辑









# **属性装饰器**

属性装饰器声明在一个属性声明之前（紧靠着属性声明）

属性装饰器通常用于修改或监视属性的行为。



属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。



## 定义一个属性装饰器

```
  function prop(target: any, propertyName: string) {
    // target是 实例成员是类的原型对象
    // propertyName成员的名字
    console.log("prop属性装饰器 is called");
    console.log(target);
    console.log(propertyName);//装饰的属性名
  }
```



使用属性装饰器 

在属性前面添加@函数名

```
  class Div {
    @prop username: string = "zhangsan";
  }
  let d: any = new Div();
```



这样使用属性装饰器，只能记录我们装饰了哪些属性，并不能再监听属性的使用或者修改



想要监听我们得使用 Object.defineProperty 的set和get来给属性，添加setter 和geter方法



```
  Object.defineProperty(要监听的对象, 监听对象的属性名, {
    get: function(){
    	//这个函数我们叫getter 会在通过获取这个属性的时候执行     obj.a
    },
    set: function(){
       //这个函数我们叫setter 会在通过设置这个属性的时候执行     obj.a=111
    },
  });
```



配合这个我们就可以监听类的属性什么时候被使用或者被修改了

下面代码我们就监听了属性的使用或者修改，也可以添加一些自己的逻辑

```
function logProperty(target: any, propertyName: string) {
  console.log(target); //装饰的类的原型
  console.log(propertyName, "被装饰属性名"); ////装饰的类的属性名
  //保存属性被设置的值
  //1- 当用我们给message属性赋值的是，setter会被执行----
  //  就会把setter里面的newValue
  let value: any;
  console.log(value);
  const getter = function () {
    console.log("监听:get ", propertyName);
    // 3-getter中返回 value的值就可以了 也就是用户设置的 newVal的值
    return value;
  };
  const setter = function (newVal: any) {
    //2- newValue 是   我们设置message属性时候传入的值， 比如 a.message= '123'  那么newVal的值就是'123'
    // 此时我们把newVal保存到到 value变量上，下次用户获取的时候，会触发getter ，getter中返回 value的值就可以了
    console.log("监听 set: ", propertyName);
    value = newVal;
  };
  Object.defineProperty(target, propertyName, {
    get: getter,
    set: setter,
  });
}

class MyClass {
  @logProperty
  message: string = "Hello"; //定义属性的时候给message设置初始值，会出发 setter
}

const a = new MyClass();
a.message; //获取的时候，会出发setter
```









#  声明文件



 ***通过会把类型，声明都放入一个文件中（声明文件的后缀必须是types.d.ts） ，也是环境声明

 声明文件的中类型不需要手动导入，会**自动导入**当前项目

 但是声明文件的位置必须写到 ，ts配置文件规定的地方-》"include": ["src"]

创建 types.d.ts

```
interface ILoginParams{

​    username:string,

​    password:string,
}
```

不需要导出，也不需要导入到ts文件中，项目中src文件下面的ts文件会自动导入里面的类型



## 手动导出类型

如果是自己导出的类型，必须 通过

 import type {ILoginParams} 导入

export  type  {ILoginParams}  导出的





# tsconfig.json

在文章开头环境安装部分，记得我们有生成一个 tsconfig.json 文件，那么这个文件究竟有什么用呢

tsconfig.json 是 TypeScript 项目的配置文件。

tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。

### 重要字段

- files - 设置要编译的文件的名称；
- include - 设置需要进行编译的文件，支持路径模式匹配；
- exclude - 设置无需进行编译的文件，支持路径模式匹配；
- compilerOptions - 设置与编译流程相关的选项。

### compilerOptions 选项

```json
json复制代码{
  "compilerOptions": {

    /* 基本选项 */
    "target": "es5",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
    "module": "commonjs",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    "lib": [],                             // 指定要包含在编译中的库文件
    "allowJs": true,                       // 允许编译 javascript 文件
    "checkJs": true,                       // 报告 javascript 文件中的错误
    "jsx": "preserve",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
    "declaration": true,                   // 生成相应的 '.d.ts' 文件
    "sourceMap": true,                     // 生成相应的 '.map' 文件
    "outFile": "./",                       // 将输出文件合并为一个文件
    "outDir": "./",                        // 指定输出目录
    "rootDir": "./",                       // 用来控制输出目录结构 --outDir.
    "removeComments": true,                // 删除编译后的所有的注释
    "noEmit": true,                        // 不生成输出文件
    "importHelpers": true,                 // 从 tslib 导入辅助工具函数
    "isolatedModules": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.

    /* 严格的类型检查选项 */
    "strict": true,                        // 启用所有严格类型检查选项
    "noImplicitAny": true,                 // 在表达式和声明上有隐含的 any类型时报错
    "strictNullChecks": true,              // 启用严格的 null 检查
    "noImplicitThis": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'

    /* 额外的检查 */
    "noUnusedLocals": true,                // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,            // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)
    "baseUrl": "./",                       // 用于解析非相对模块名称的基目录
    "paths": {},                           // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                       // 包含类型声明的文件列表
    "types": [],                           // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    "sourceRoot": "./",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                       // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,        // 启用装饰器
    "emitDecoratorMetadata": true          // 为装饰器提供元数据的支持
  }
}
```



