# day05-作用域-数据-数据类型存储

## 今日学习目标

1. 作用域
2. 变量使用规则
3. 递归函数
4. 对象数据类型
5. 数组数据类型
6. 不同数据类型的存储

## 1. 作用域（重点）

- 什么是作用域，就是一个变量可以生效的范围
  - 变量不是在所有地方都可以使用的，而这个变量的使用范围就是作用域
  - 也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
- 作用域分类
  - 全局作用域
  - 局部作用域也叫私有作用域或者函数作用域
- 作用域上下级关系
  - 你在哪一个作用域下书写的函数, 就是哪一个作用域的子级作用域



### 1) 全局作用域

- 全局作用域是最大的作用域

- 在全局作用域中定义的变量可以在任何地方使用

- 页面打开的时候，浏览器会自动给我们生成一个全局作用域 window

- 这个作用域会一直存在，直到页面关闭就销毁了

  ```javascript
  // 下面两个变量都是存在在全局作用域下面的，都是可以在任意地方使用的
  var num = 100
  var num2 = 200
  // 在全局作用域下书写了一个 函数f1
  // 此时 f1 也是在全局作用域下
  function f1() {}
  ```



### 2) 局部作用域

- 局部作用域就是在全局作用域下面有开辟出来的一个相对小一些的作用域

- 在局部作用域中定义的变量只能在这个局部作用域内部使用

- **在 JS 中只有函数能生成一个局部作用域，别的都不行**

- 每一个函数，都是一个局部作用域

  ```javascript
  // 这个 num 是一个全局作用域下的变量 在任何地方都可以使用
  var num = 100
  
  function fn() {
    // 下面这个变量就是一个 fn 局部作用域内部的变量
    // 只能在 fn 函数内部使用
    var num2 = 200
  }
  
  fn()
  ```

  

## 2. 变量使用规则（重点）

- 有了作用域以后，变量就有了使用范围，也就有了使用规则
- 变量使用规则分为两种，**访问规则** 和 **赋值规则**

### 1)定义规则

- 你定义在哪一个作用域下的变量，就是哪一个作用域的私有变量

- 该变量只能在该作用域及其后代作用域中使用

  ```javascript
  function f1() {
      // f2 : 定义在 f1 私有作用域的变量
      // 只能在 f1 及其 f1 的后代作用域内使用
      // 全局不能使用 f2
      function f2() {
          // 这里可以使用 num 吗 ?
          // 可以, 因为 f2 是 f1 的后代作用域
          console.log(num);
      }
      f2()
      // num 只能在 f1 和 f1 的后代作用域内使用
      var num = 100
  }
  f1()
  ```

  

### 2) 访问规则

- 当我想获取一个变量的值的时候，我们管这个行为叫做 **访问**

- 获取变量的规则： 

  - 首先，在自己的作用域内部查找，如果有，就直接拿来使用
  - 如果没有，就去上一级作用域查找，如果有，就拿来使用
  - 如果没有，就继续去上一级作用域查找，依次类推
  - 如果一直到全局作用域都没有这个变量，那么就会直接报错（该变量 is not defined）

  ```javascript
  var num = 100
  
  function fn() {
    var num2 = 200
    
    function fun() {
      var num3 = 300
      
      console.log(num3) // 自己作用域内有，拿过来用
      console.log(num2) // 自己作用域内没有，就去上一级，就是 fn 的作用域里面找，发现有，拿过来用
      console.log(num) // 自己这没有，去上一级 fn 那里也没有，再上一级到全局作用域，发现有，直接用
      console.log(a) // 自己没有，一级一级找上去到全局都没有，就会报错
    }
    
    fun()
  }
  
  fn()
  ```

  - 变量的访问规则 也叫做 作用域的查找机制

  - 作用域的查找机制只能是向上找，不能向下找


  ```javascript
  function fn() {
    var num = 100
  }
  fn()
  
  console.log(num) // 发现自己作用域没有，自己就是全局作用域，没有再上一级了，直接报错
  ```

  #### 案例

  ```javascript
  var n = 100
  function fn(n) {
      // 形参 n 就相当于 fn 函数内部的私有变量 n
      // fn 私有作用域内有 n 变量, 值是 undefined
      var n = 200
      function fun() {
          // var n = 300
          console.log(n)
      }
      fun()
  }
  fn()
  ```

  


### 3) 赋值规则

- 当你想给一个变量赋值的时候，那么就先要找到这个变量，在给他赋值

- 变量赋值规则：

  - 先在自己作用域内部查找，有就直接赋值
  - 没有就去上一级作用域内部查找，有就直接赋值
  - 在没有再去上一级作用域查找，有就直接赋值
  - 如果一直找到全局作用域都没有，那么就把这个变量定义为全局变量，在给他赋值

  ```javascript
  function fn() {
    num = 100
  }
  fn()
  
  // fn 调用以后，要给 num 赋值
  // 查看自己的作用域内部没有 num 变量
  // 就会向上一级查找
  // 上一级就是全局作用域，发现依旧没有
  // 那么就会把 num 定义为全局的变量，并为其赋值
  // 所以 fn() 以后，全局就有了一个变量叫做 num 并且值是 100
  console.log(num) // 100
  ```

  #### 案例
  
  ```javascript
  // var n = 100
  function fn() {
      //   因为 var n 这句代码, 导致 fn 私有作用域内有 n 这个私有变量
      // var n = 200
      console.log('n 赋值之前 :', n)
      n = 300
      console.log('n 赋值之后 :', n)
  }
  console.log('fn 执行之前 : ', n)
  // 因为 fn 函数内的某一行代码执行
  // 导致在全局定义了一个叫做 n 的变量
  fn()
  console.log('fn 执行之后 : ', n)
  ```



## 3. 作用域链

- 变量取值是到创建这个变量的函数的作用域中取值。但是如果在当前作用域中没有查找到值，就会向上级作用域去查找，直到查找到全局作用域，这么一个查找过程形成的链条就叫做作用域链
- 由于变量的查找是沿着作用域链来实现的，所以也称作用域链为变量查找的机制



## 4. 预解析 ( 重点 ) 

- 预解析 其实就是聊聊 js 代码的编译和执行
- js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码
- 也就是说，我们的 js 代码在运行的时候，会经历两个环节 解释代码 和 执行代码
- JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理
- 处理过程：当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。

### 1) 解释代码和执行代码

- 因为是在所有代码执行之前进行解释，所以叫做 预解析（预解释）
- 需要解释的内容有两个
  - var 关键字
    - 在内存中先声明有一个变量名
    - 会把 var 关键字声明的变量进行提前说明, 但是不进行赋值
  - 声明式函数
    - 在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数
    - 也就是会把函数名进行提前声明, 并且赋值为一个函数

### 2) 解析var关键字

```javascript
// 1. 解析 var 关键字
console.log(num)
var num = 100
console.log(num)
```

- 代码分析：

​	预解析

​		var num

​		告诉浏览器, 我定义了一个叫做 num 的变量, 但是没有赋值

​	代码执行

​		第 1 行代码, 在控制台打印 num 变量的值

​		因为预解析的时候, 已经声明过 num 变量, 只是没有赋值

​		num 变量是存在的

​		打印出来的是 undefined

​		第 2 行代码, num = 100

​		给已经定义好的 num 变量赋值为 100 这个数据

​		第 3 行代码, 在控制台打印 num 变量的值

​		因为第 2 行代码的执行, num 已经被赋值为 100 了

​		此时打印出来的内容是 100

### 3) 解析声明式函数

```javascript
//解析声明式函数
fn()
function fn() { console.log('fn 函数') }
fn()
```

- 代码分析 ：

​		预解析

​			function fn() { console.log('fn 函数') }

​			告诉浏览器, 我定义了一个 fn 变量, 并且 fn 变量保存的内容是一个函数

​		代码执行

​			第 1 行代码, fn()

​			拿到 fn 变量存储的值, 当做一个函数来调用

​			因为预解析阶段 fn 存储的就是一个函数

​			调用没有问题

​			第 3 行代码, fn()

​			拿到 fn 变量存储的值, 当做一个函数来调用

​			因为预解析阶段 fn 存储的就是一个函数

​			调用没有问题 

### 4) 预解析优先级

```javascript
fn()
console.log(num)
function fn() {
    console.log('我是 fn 函数')
}
var num = 100
```

经过预解析之后可以变形为

```JavaScript
function fn() {
    console.log('我是 fn 函数')
}
var num
fn()
console.log(num)
num = 100
```

### 5) 预解析中重名问题

1. 当你使用 var 定义变量 和 声明式函数 重名的时候, 以 函数为主
2. 只限于在预解析阶段, 以函数为准

​	**<u>案例</u>**

```JavaScript
num()
var num = 100
num()
function num() { console.log('我是 num 函数') }
num()
```

- 代码分析 ：

​		预解析

​			var num

​			告诉浏览器我定义了一个叫做 num 的变量, 但是并没有赋值

​			function num() { console.log('我是 num 函数') }

​			告诉浏览器我定义了一个叫做 num 的变量, 并且赋值为一个函数

​			预解析结束阶段, num 变量存在, 并且是一个函数

​		执行代码

​			第 1 行代码, num()

​			拿到 num 的值当做一个函数来调用

​			因为预解析阶段, num 就是一个函数

​			所以正常调用

​			第 2 行代码, num = 100

​			给 num 变量赋值为 100

​			因为 num 本身保存的是一个函数, 现在赋值为 100

​			就把 函数 覆盖了, 一个变量只能保存一个值

​			从此以后, num 就是 100 了

​			第 3 行代码, num()

​			拿到 num 的值当做一个函数来调用

​			因为第 2 行的代码执行, 已经把 num 赋值为 100 

​			此时就是把 数字 100 当做一个函数来调用

​			报错: num is not a function

**<u>	案例</u>**

```JavaScript
num()
function num() { console.log('我是 num 函数') }
num()
var num = 100
num()
```

- 代码分析：

​		预解析

​			function num() { console.log('我是 num 函数') }

​			告诉浏览器, 我定义了一个叫做 num 的变量, 并且赋值为一个函数

​			var num

​			告诉浏览器, 我定义了一个叫做 num 的变量, 但是没有赋值

​			预解析结束的时候, num 变量存在, 并且是一个函数

​		代码执行

​			第 1 行代码, num()

​			把 num 存储的值拿来当做一个函数调用

​			因为预解析阶段, 确定了 num 就是一个函数

​			调用没有问题

​			第 3 行代码, num()

​			把 num 存储的值拿来当做一个函数调用

​			因为预解析阶段, 确定了 num 就是一个函数

​			调用没有问题

​			第 4 行代码, num = 100

​			把 num 赋值为 100

​			本身保存的函数就被覆盖了

​			从此以后, num 就是 100 了

​			第 5 行代码, num()

​			把 num 存储的值拿来当做一个函数调用

​			因为第 4 行代码的执行, 导致 num 是一个 数字 100

​			把 数字 100 当做函数调用

​			报错: num is not a function

### 6) 预解析中特殊情况

​	在代码中, 不管 if 条件是否为 true, if 语句代码里面的内容依旧会进行预解析

```JavaScript
//预解析的特殊情况
// 1. if语句
console.log(num) // undefined
if (true) {
    // 第一件事: var num
    // 第二件事: num = 100
    var num = 100
}
console.log(num)
```

函数体内, return 后面的代码虽然不执行, 但是会进行预解析

```javascript
//预解析的特殊情况
// 2.return后面
function fn() {
    console.log('我是 fn 内的代码')
    console.log(num) // undefined
    return
    // 第一件事: var num
    // 第二件事: num = 100
    var num = 100
    console.log(num)
}
fn()
```



## 5. 递归函数 ( 了解 )

- 什么是递归函数

- 在编程世界里面，递归就是一个自己调用自己的手段

- 递归函数： 一个函数内部，调用了自己，循环往复

  ```javascript
  // 下面这个代码就是一个最简单的递归函数
  // 在函数内部调用了自己，函数一执行，就调用自己一次，在调用再执行，循环往复，没有止尽
  function fn() {
    fn()
  }
  fn()
  ```

- 其实递归函数和循环很类似

- 需要有初始化，自增，执行代码，条件判断的，不然就是一个没有尽头的递归函数，我们叫做 **死递归**



### 1) 简单实现一个递归

- 我们先在用递归函数简单实现一个效果

- 需求： 求 1 至 5 的和

  - 先算 1 + 2 得 3
  - 再算 3 + 3 得 6
  - 再算 6 + 4 得 10 
  - 再算 10 + 5 得 15
  - 结束

- 开始书写，写递归函数先要写结束条件（为了避免出现 “死递归”）

  ```javascript
  function add(n) {
    // 传递进来的是 1
    // 当 n === 5 的时候要结束
    if (n === 5) {
      return 5
    }
  }
  
  add(1)
  ```

- 再写不满足条件的时候我们的递归处理

  ```javascript
  function add(n) {
    // 传递进来的是 1
    // 当 n === 5 的时候要结束
    if (n === 5) {
      return 5
    } else {
      // 不满足条件的时候，就是当前数字 + 比自己大 1 的数字
      return n + add(n + 1)
    }
  }
  add(1)
  ```

- 递归案例:( 递归求阶乘, 递归求斐波那契数列, ... )

  

## 6. 对象数据类型

### 1) 了解对象

- 对象是一个复杂数据类型

- 其实说是复杂，但是没有很复杂，只不过是存储了一些基本数据类型的一个集合

  ```javascript
  var obj = {
    num: 100,
    str: 'hello world',
    boo: true
  }
  ```

- 这里的 `{}` 和函数中的 `{}` 不一样

- 函数里面的是写代码的，而对象里面是写一些数据的

- **对象就是一个键值对的集合**

- `{}` 里面的每一个键都是一个成员

- 也就是说，我们可以把一些数据放在一个对象里面，那么他们就互不干扰了

- 其实就是我们准备一个房子，把我们想要的数据放进去，然后把房子的地址给到变量名，当我们需要某一个数据的时候，就可以根据变量名里面存储的地址找到对应的房子，然后去房子里面找到对应的数据



### 2) 创建一个对象

- 字面量的方式创建一个对象

  ```javascript
  // 创建一个空对象
  var obj = {}
  
  // 像对象中添加成员
  obj.name = 'Jack'
  obj.age = 18
  ```

- 内置构造函数的方式创建对象

  ```javascript
  // 创建一个空对象
  var obj = new Object()
  
  // 向对象中添加成员
  obj.name = 'Rose'
  obj.age = 20
  ```

  - Object 是 js 内置给我们的构造函数，用于创建一个对象使用的

### 3) 对象操作

- 对象的操作就是操作里面的数据，分为：增、删、改、查
- 操作对象上的数据有两种语法：点语法和数组关联语法
- 点语法
  - 增: 对象名.键名 = 值
  - 删: delete 对象名.键名
  - 改: 对象名.键名 = 值
  - 查: 对象名.键名

```javascript
// 准备一个空对象
var obj = {}
console.log(obj)
// 1. 增加
obj['name'] = '安安'
obj['age'] = 18
obj['gender'] = '男'
console.log(obj) // { age: 18, name: '安安', gender: '男' }
// 2. 删除
delete obj['gender']
console.log(obj) // { age: 18, name: '安安' }
// 3. 修改
obj['name'] = '小安'
console.log(obj) // { age: 18, name: '小安' }
// 4. 查询
console.log(obj['name']) // '小安'
console.log(obj['age']) // 18
console.log(obj['gender']) // undefined
```

### 4) 对象操作的区别

- 对于名字的操作

  - 如果是符合变量命名规则和规范的键名, 两种语法都可以

  - 纯数字只能使用数组关联语法, 不能使用点语法

  - 带有特殊符号的, 只能使用数组关联语法, 不能使用点语法

```JavaScript
// 准备一个对象
var obj = {
    a1: 100,
    $5: 200,
    _346: 400,
    1: true,
    2: 'hello world',
    '#abc': 33,
    'font-size': '50px'
}

// 访问
console.log(obj.a1) 
console.log(obj['a1'])

console.log(obj.$5)
console.log(obj['$5'])

console.log(obj._346)
console.log(obj['_346'])

console.log(obj[1])
console.log(obj.1) // 会报错

console.log(obj.#abc);//会报错
console.log(obj['#abc']);

console.log(obj['font-size'])
console.log(obj.font - size) // 不行, 变成了 obj.font 和 size 进行减法运算
```

- 和变量相关的时候

  - 点语法, 不管如何, 都不能和变量产生联系。始终都是访问的对象内某一个准确的键名

  - 数组关联语法, 当你的 [] 内书写的是一个变量的时候，会把变量解析出来填充在 [] 内

```JavaScript
// 和变量相关的访问
var obj = {
    name: '唐僧',
    age: 100,
    1: true
}
var a = 'name'

// 使用点语法的时候
console.log(obj.name) // 访问 obj 内一个叫做 name 的键
console.log(obj.a) // 访问 obj 内一个叫做 a 的键, 和 a 变量没有任何关系

console.log(obj['a']) // 访问 obj 内一个叫做 a 的键, 和 a 变量没有任何关系

console.log(obj[a]) // 访问 obj 内一个叫做 name 键
```

### 5) 对象遍历

- 对象没有办法使用 for 循环来进行遍历

  - 因为 for 循环能提供的是一组有规律的数字
  - 但是对象内存放的是键值对，键名是没有规律的

- 使用for  in 来循环遍历

  - for  in 的主要作用就是用来遍历对象数据类型的

  - 语法: 

    ```JavaScript
    for (var 变量名 in 对象名) {
        // 重复执行的代码, 对象内有多少个成员, 就执行多少回
        // 对象名[键名] 就是对象中的每一个成员的值
      }
    ```

  - 示例

    ```javascript
    var obj = {
        name: 'jack',
        age: 18,
        gender: '男',
    }
    for (var key in obj) {
        //拿到所有的键名
        console.log(key);
        //拿到所有的键值
        console.log(obj[key]);
    }
    ```



## 7.数组数据结构

### 1) 了解数组

- 数组就是一组数据的集合，用中括号 []表示
- 数组也是一种数据类型，属于复杂数据类型Array
- 数组里面的数据排列是按照一定顺序排列的，也叫有序的数据集合
- 数组里面所有数据的排列都是按照序号进行排列的
- 我们管 "序号" 叫做 索引 或者 下标
- 索引: 从0开始, 依次+1
- 在 [] 里面存储着各种各样的数据，按照顺序依次排好

### 2) 数组的特点

- 数组定义时无需指定数据类型
- 数组定义时可以无需指定数组长度
- 数组可以存储任何数据类型的数据

### 3) 创建一个数组

#### 	1)字面量创建一个数组

​		直接使用 [] 的方式创建一个数组		

```javascript
// 创建一个空数组
var arr1 = []
console.log(arr1);
// 创建一个有内容的数组
var arr2 = [1, 2, 3]
console.log(arr2);
```

#### 	2)内置构造函数创建数组

​		使用 js 的内置构造函数 Array 创建一个数组

```JavaScript
// 内置构造函数创建数组
var arr = new Array()
console.log(arr)

// 表示创建一个长度为 10 的数组
// 每一个位置都使用 empty 填充
var arr2 = new Array(10)
console.log(arr2)

// 此时创建了一个数组, 内部有三个数据, 分别是 10 20 和 30
// 此时的 10 不在表示数组的长度, 而是数组内的第一个数据
var arr3 = new Array(10, 20, 30)
console.log(arr3)
```

### 4) 数组的length属性

- length:  长度的意思
- length 就是表示数组的长度，数组里面有多少个成员，length 就是多少
- length的功能有读写功能
  - 读
    - 作用：获取到的就是该数组的长度, 也就是数组内有多少个数据
    - 语法：数组名.length
  - 写
    - 作用：设置该数组的长度
      - 设置的数字和原始长度一样, 相当于没有设置
      - 设置的数字比原始长度大, 多出来的位置, 用 empty 补齐
      - 设置的数字比原始长度小, 从后面开始删除
    - 语法：数组名.length = 数字

```javascript
/ 数组的 length 属性
var arr = [100, 200, 300, 400, 500]

// length 获取
console.log(arr.length)

// length 设置
// 和原先长度一样, 相当于没有设置
arr.length = 5
console.log(arr)

// 比原先长度大, 用 empty 补齐
arr.length = 100
console.log(arr)

// 比原先长度小, 从后面开始删除数据
arr.length = 3
console.log(arr)
```

### 5) 数组的索引

- 索引，也叫做下标，是指一个数据在数组里面排在第几个的位置
  - 注意： 在所有的语言里面，索引都是从 0 开始的
- 在 js 里面也一样，数组的索引从 0 开始
- 索引的功能也有读写能力
  - 读
    - 作用：获取数组该索引位置的数据
      - 如果数组有该索引位置, 那么就是该索引位置的数据
      - 如果数组没有该索引位置, 那么就是 undefined
    - 语法：数组[索引]
  - 写
    - 作用：给数组的某一个索引位置进行赋值
      - 如果原先数组中就有该索引位置, 那么就是修改
      - 如果原先数组中没有该索引位置, 那么就是添加
      - 如果你设置的索引刚好和 length 一样, 那么就是在最后追加
      - 如果你设置的索引大于 length, 那么中间空出来的位置用 empty 补齐, 为了保证最后一位的索引一定是 length - 1
    - 语法：数组[索引] = 值

```JavaScript
// 数组的 索引 属性

var arr = [100, 200, 300, 400, 500]

// 索引获取
// 获取数组中索引为 2 对应的数据
console.log(arr[2])

//因为没有索引是100的这个数据，返回的就是undefined
console.log(arr[100]) //undefined

//索引设置
// 因为数组有 [2] 位置, 相当于把 [2] 位置的数据修改了
arr[2] = '我是刚来的'
console.log(arr)

// 因为数组没有 [5] 位置, 相当于添加
// 又因为 5 刚好的 length 一样, 就相当于在数组后面追加数据
arr[5] = 'hello'
console.log(arr)

// 因为数组没有 [10] 位置, 相当于添加
// 如果只是单纯的添加一个 '世界' 在 [10] 的位置, 那么一共就是 6 个数据, 
//你设置的最后一个索引又是 [10] , 数组就不对了
// 所以, 他为了保证最后一位的索引一定是 length - 1, 从索引 5 ~ 索引9都用 empty 填充
// 保证了长度依旧是 11
arr[10] = '大家好'
console.log(arr) //[100, 200, '我是刚来的', 400, 500, 'hello', empty × 4, '大家好']
```



### 6) 数组的操作案例

案例1 : 求数组内所有数据的和

```JavaScript
/ 求数组内所有数据的和

// 0. 准备一个数组
var arr = [100, 200, 300, 400, 500]

// 1. 准备一个变量, 接受叠加结果
var sum = 0

// 2. 循环遍历数组, 拿到每一个数字
for (var i = 0; i < arr.length; i++) {
    // 3. 把数组内每一个数据添加到 sum 身上
    sum += arr[i]
}

console.log(sum)
```

案例2 : 把10 ~ 20 之间的所有数字保存到数组里面

```javascript
//把10 ~ 20 之间的所有数字保存到数组里面
//既然要放到一个数组里面就需要准备一个空数组用来存放
var arr = []
console.log(arr.length); //0
//循环遍历得到这些数字
for (var i = 10; i <= 20; i++) {
    console.log(i);
    //把得到的数组题添加到数组里面
    //利用 索引 可以写入的方式来进行添加
    // 当你没有这个索引的时候, 是添加
    // 当索引刚好和 length 一样的时候, 就是追加
    arr[arr.length] = i
}
console.log(arr);
```



## 8. 数据存储

- 通过前面的学习我们知道。数据类型分为基本数据类型（简单数据类型）和复杂数据类型（引用数据类型）
- 基本数据类型和复杂数据类型最大的区别就是存储上的区别
- 我们的存储空间分为栈和堆
  - 栈：主要存放基本数据类型的内容
  - 堆：主要存放复杂数据类型的内容
- 复杂数据类型存放在堆内存中。无序排列, 根据地址来查找(堆空间地址)

### 1) 基本数据类型存储

- var num = 100，在内存中的存储情况
- 直接在 栈空间 内有存储一个数据
- 栈内存: 按序排列, 先来的在栈底, 后来的在栈顶

<img src="pic1.png">

### 2) 复杂数据类型存储

```javascript
var obj = {
    name: 'Jack',
    age: 18,
    gender: '男'
}
```

<img src="pic2.png">

- 复杂数据类型的存储
  - 在堆里面开辟一个存储空间
  - 把数据存储到存储空间内
  - 把存储空间的地址赋值给栈里面的变量

### 3) 数据类型赋值

- 基本数据类型赋值
  - 赋值的时候, 就是直接值的复制
  - 赋值以后, 两个变量互相之间没有任何关系
  - 改变一个变量, 另一个不会发生变化

```javascript
var n = 10
// 把 n 存储的值赋值给了 m 变量
var m = n
console.log(m)
console.log(n)
m = 20
console.log(m) 
console.log(n)
```

- 复杂数据类型赋值
  - 复杂数据类型赋值的时候, 是把变量内存储的地址进行赋值
  - 赋值以后, 两个变量操作的是一个存储空间
  - 任意一个变量去改变存储空间内的数据, 另一个变量看到的一样是改变以后的

```javascript
var obj = { name: '武松' }
// 把 obj 存储的值复制了一份给了 obj2
var obj2 = obj

console.log(obj)
console.log(obj2)

obj2.name = '宋江'
console.log(obj)
console.log(obj2)
```



### 4) 数据类型比较

- 基本数据类型, 就是 值 和 值 之间的比较

```javascript
var n = 10
var m = 10
console.log(n == m)
```

- 复杂数据类型, 是 地址 和 地址 之间的比较

```javascript
var o1 = {
    name: 'Jack'
}
var o2 = {
    name: 'Jack'
}
console.log(o1 == o2) //false
```

- 因为我们创建了两个对象，那么就会在 堆空间 里面开辟两个存储空间存储数据（两个地址）
- 虽然存储的内容是一样的，那么也是两个存储空间，两个地址
- 复杂数据类型之间就是地址的比较，所以 obj 和 obj2 两个变量的地址不一样
- 所以我们得到的就是 false